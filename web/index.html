<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Web 与网络 | Study Note</title>
    <meta name="description" content="学无止境">
    <meta name="generator" content="VuePress 1.3.1">
    
    
    <link rel="preload" href="/assets/css/0.styles.26cb1efd.css" as="style"><link rel="preload" href="/assets/js/app.ed89f765.js" as="script"><link rel="preload" href="/assets/js/2.ee146c9e.js" as="script"><link rel="preload" href="/assets/js/6.d71a63f2.js" as="script"><link rel="prefetch" href="/assets/js/10.6fe08578.js"><link rel="prefetch" href="/assets/js/11.cd75cff5.js"><link rel="prefetch" href="/assets/js/12.b67c738f.js"><link rel="prefetch" href="/assets/js/13.a7be6b36.js"><link rel="prefetch" href="/assets/js/14.0f3b09e8.js"><link rel="prefetch" href="/assets/js/15.2567e81a.js"><link rel="prefetch" href="/assets/js/16.7263d1e0.js"><link rel="prefetch" href="/assets/js/17.1fe48087.js"><link rel="prefetch" href="/assets/js/18.cb193d83.js"><link rel="prefetch" href="/assets/js/19.cf3fadcc.js"><link rel="prefetch" href="/assets/js/20.2aee8557.js"><link rel="prefetch" href="/assets/js/3.cad49ef4.js"><link rel="prefetch" href="/assets/js/4.46766430.js"><link rel="prefetch" href="/assets/js/5.2b008b93.js"><link rel="prefetch" href="/assets/js/7.6919d521.js"><link rel="prefetch" href="/assets/js/8.b3808f66.js"><link rel="prefetch" href="/assets/js/9.6ebcb2ff.js">
    <link rel="stylesheet" href="/assets/css/0.styles.26cb1efd.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Study Note</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/js/" class="sidebar-link">js 基础</a></li><li><a href="/css/" class="sidebar-link">CSS 基础</a></li><li><a href="/css-practice/" class="sidebar-link">CSS 应用</a></li><li><a href="/dac/" class="sidebar-link">数据结构与算法</a></li><li><a href="/web/" class="active sidebar-link">Web 与网络</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/web/#小知识" class="sidebar-link">小知识</a></li><li class="sidebar-sub-header"><a href="/web/#htpp2" class="sidebar-link">HTPP2</a></li><li class="sidebar-sub-header"><a href="/web/#渲染" class="sidebar-link">渲染</a></li><li class="sidebar-sub-header"><a href="/web/#事件模型" class="sidebar-link">事件模型</a></li><li class="sidebar-sub-header"><a href="/web/#ajax" class="sidebar-link">AJAX</a></li><li class="sidebar-sub-header"><a href="/web/#图片" class="sidebar-link">图片</a></li><li class="sidebar-sub-header"><a href="/web/#从-url-输入开始" class="sidebar-link">从 URL 输入开始</a></li><li class="sidebar-sub-header"><a href="/web/#web-安全" class="sidebar-link">WEB 安全</a></li><li class="sidebar-sub-header"><a href="/web/#常见项目优化" class="sidebar-link">常见项目优化</a></li><li class="sidebar-sub-header"><a href="/web/#http-状态码" class="sidebar-link">HTTP 状态码</a></li><li class="sidebar-sub-header"><a href="/web/#cors（跨域资源共享）" class="sidebar-link">CORS（跨域资源共享）</a></li></ul></li><li><a href="/git/" class="sidebar-link">git</a></li><li><a href="/linux/" class="sidebar-link">Linux</a></li><li><a href="/nginx/" class="sidebar-link">Nginx</a></li><li><a href="/node/" class="sidebar-link">node</a></li><li><a href="/react/" class="sidebar-link">React</a></li><li><a href="/vue/" class="sidebar-link">Vue</a></li><li><a href="/write/" class="sidebar-link">js 手写系列</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="web-与网络"><a href="#web-与网络" class="header-anchor">#</a> Web 与网络</h1> <h2 id="小知识"><a href="#小知识" class="header-anchor">#</a> 小知识</h2> <h3 id="术语缩写"><a href="#术语缩写" class="header-anchor">#</a> 术语缩写</h3> <ul><li><code>WWW</code> (Word Wide Web) 万维网</li> <li><code>AJAX</code> (Asynchronous JavaScript and XML) 异步 JavaScript 与 XML 技术</li> <li><code>URI</code> (Uniform Resource Identifier) 统一资源标识符</li> <li><code>URL</code> (Uniform Resource Locator) 统一资源定位符</li> <li><code>HTML</code> (HyperText Markup Language) 超文本标记语言</li> <li><code>HTTP</code> (HyperText Transfer Protocol) 超文本状态转移协议</li> <li><code>FTP</code> (File Transfer Protocol) 文件传输协议</li> <li><code>DNS</code> (Domain Name System) 域名系统</li> <li><code>TCP</code> (Transmission Control Protocol) 传输控制协议</li> <li><code>SYN</code> (Synchronize Sequence Numbers) 同步序列编号</li> <li><code>ACK</code> (Acknowledgement) 确认字符</li> <li><code>UDP</code> (User Data Protocol) 用户数据报协议</li> <li><code>MAC</code> (Media Access Control Address) 网卡固定地址</li> <li><code>ARP</code> (Address Resolution Protocol) 解析地址的协议（根据通信方的 IP 地址反查出对应的 MAC 地址）</li> <li><code>REST</code> (Representational State Transfer) 表征状态转移</li> <li><code>SSL</code> (Secure Sockets Layer) 安全套接层</li> <li><code>TLS</code> (Transport Layer Security) 传输层安全</li> <li><code>Dos</code> (Denial of Service) 拒绝服务攻击</li> <li><code>CDN</code> (Content Delivery Network) 内容分发网络</li> <li><code>SSO</code> (Single Sign On) 单点登录</li> <li><code>CAS</code> (Central Authentication Service) 中央认证服务</li> <li><code>CORS</code> (cross-origin resource-sharing) 跨域资源共享标准</li></ul> <h3 id="容量"><a href="#容量" class="header-anchor">#</a> 容量</h3> <p>1 字节（Byte）= 8 比特（bit)（也就是位）</p> <p>1KB = 1000Byte</p> <p>1KiB = 1024Byte</p> <h3 id="编码与解码"><a href="#编码与解码" class="header-anchor">#</a> 编码与解码</h3> <p><code>encodeURI</code>、<code>decodeURI</code>、<code>encodeURIComponent</code>、<code>decodeURIComponent</code></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">encodeURI</span><span class="token punctuation">(</span><span class="token string">&quot;http://www.baidu.com/My First&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">encodeURIComponent</span><span class="token punctuation">(</span><span class="token string">&quot;http://www.baidu.com/My First&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// http://www.baidu.com/My%20First</span>
<span class="token comment">// http%3A%2F%2Fwww.baidu.com%2FMy%20First</span>
<span class="token function">decodeURI</span><span class="token punctuation">(</span><span class="token string">&quot;http://www.baidu.com/My%20First&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">decodeURIComponent</span><span class="token punctuation">(</span><span class="token string">&quot;http%3A%2F%2Fwww.baidu.com%2FMy%20First&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="htpp2"><a href="#htpp2" class="header-anchor">#</a> HTPP2</h2> <ul><li>二进制传输</li> <li>多路复用，</li> <li>header 压缩，双方还会 cache 一份 header 数据</li> <li>服务端推送</li></ul> <h2 id="渲染"><a href="#渲染" class="header-anchor">#</a> 渲染</h2> <ul><li>script 会阻塞渲染</li> <li>link 在没有 script 的情况下不会阻塞渲染，有 script 的情况下会阻塞</li> <li>两种标签均可设置异步避免阻塞，script 使用 defer/sync，link 使用<code>media=&quot;print&quot;</code>。
<blockquote><p>async 加载后立即执行，没有顺序可言。script 按顺序异步加载，所以比 async 慢。</p></blockquote></li></ul> <h2 id="事件模型"><a href="#事件模型" class="header-anchor">#</a> 事件模型</h2> <h3 id="dom-事件模型"><a href="#dom-事件模型" class="header-anchor">#</a> DOM 事件模型</h3> <p>xxx.onclick，发生在冒泡阶段</p> <h3 id="dom-2-级模型"><a href="#dom-2-级模型" class="header-anchor">#</a> DOM 2 级模型</h3> <ul><li>捕获，目标，冒泡三个阶段</li> <li>e.currentTarget 指向注册事件的监 DOM 对象，e.target 指向事件发生的 DOM 对象</li> <li>this 指向指向注册事件的监听 DOM 对象</li></ul> <p>事件委托：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">delegate</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">delegateEl<span class="token punctuation">,</span> type<span class="token punctuation">,</span> wannaBindElSelectorString<span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  delegateEl<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> el <span class="token operator">=</span> e<span class="token punctuation">.</span>target<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>el<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span>wannaBindElSelectorString<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>el <span class="token operator">===</span> delegateEl<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        el <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      el <span class="token operator">=</span> el<span class="token punctuation">.</span>parentNode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    el <span class="token operator">&amp;&amp;</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>delegateEl<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> delegateEl<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="ajax"><a href="#ajax" class="header-anchor">#</a> AJAX</h2> <h3 id="get-与-post"><a href="#get-与-post" class="header-anchor">#</a> get 与 post</h3> <p>本质上都是万维网中传输数据的一种协议，所有的区别都来自于浏览器或者规范的限制。</p> <ul><li>语义不同</li> <li>浏览器限制<code>url</code>长度 2k 左右 -&gt; get 请求有长度限制</li> <li>不同服务器对 get 中的 request body 处理方式不同，所以 body 里面的信息不一定会被识别 -&gt; get 请求使用 url 进行透明传参</li></ul> <h2 id="图片"><a href="#图片" class="header-anchor">#</a> 图片</h2> <h3 id="优化手段"><a href="#优化手段" class="header-anchor">#</a> 优化手段</h3> <ul><li>webpack 压缩，并开启渐进效果提升体验。</li> <li>按需加载。使用 IntersectionObserver 可监听元素进入视野内，使用 chrome 特有的 loading 属性。</li> <li>固定图片设置背景渐变色，用工具获取色值。</li> <li>retina 屏幕，img 标签使用 srcset 属性。</li> <li>webP。使用 picture 标签加载多种格式图片来兼容处理，.webp 排第一位。也可以使用 cdn 判断。</li></ul> <h3 id="懒加载图片"><a href="#懒加载图片" class="header-anchor">#</a> 懒加载图片</h3> <p>实现原理：元素的 offsetTop &lt; 页面的 scrollTop + 页面的 clientHeight</p> <p>元素 offsetTop 的获取：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">getH</span><span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> h <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    h <span class="token operator">+=</span> el<span class="token punctuation">.</span>offsetTop<span class="token punctuation">;</span>
    el <span class="token operator">=</span> el<span class="token punctuation">.</span>offsetParent<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> h<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="从-url-输入开始"><a href="#从-url-输入开始" class="header-anchor">#</a> 从 URL 输入开始</h2> <h3 id="_1-dns-解析"><a href="#_1-dns-解析" class="header-anchor">#</a> 1. dns 解析</h3> <p>通过域名找寻 ip 地址</p> <h4 id="顺序"><a href="#顺序" class="header-anchor">#</a> 顺序</h4> <ol><li>浏览器缓存</li> <li>系统缓存</li> <li>host 文件</li> <li>LocalDNS 服务器</li></ol> <ul><li>a. 请求根域名服务器（RootDNS），得到主域名服务器（ gTLDServer）地址</li> <li>b. 请求主域名服务器（ gTLDServer），如 .com、 .cn、. org 等，得到域名提供商服务器地址（NameServer）</li> <li>c. 请求域名提供商服务器地址（NameServer），如<code>xxx.com</code>，至此获得 IP 和 TTL 值
<blockquote><p>dns 缓存存在多级，例如浏览器缓存、系统缓存、路由器缓存、IPS 服务器缓存、根域名服务器缓存、顶级域名服务器缓存、主域名服务器缓存。</p></blockquote></li></ul> <h4 id="优化"><a href="#优化" class="header-anchor">#</a> 优化</h4> <ul><li>减少 DNS 的请求次数</li> <li>DNS 预解析<div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>x-dns-prefetch-control<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>on<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>dns-prefetch<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>//example.com<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div></li> <li>CDN，通过在现有的 Internet 中增加一层新的 CACHE(缓存)层，将网站的内容发布到最接近用户的网络”边缘“的节点</li> <li>HTTPDNS，使用 HTTP 协议替代 UDP 协议，绕过 LocalDNS，可以有效防止域名劫持</li> <li>DNS 负载均衡（根据权重轮询返回不同的服务器地址）</li></ul> <h3 id="_2-查询缓存决定是否发送-http-请求"><a href="#_2-查询缓存决定是否发送-http-请求" class="header-anchor">#</a> 2. 查询缓存决定是否发送 HTTP 请求</h3> <h4 id="强缓存"><a href="#强缓存" class="header-anchor">#</a> 强缓存</h4> <p>服务端通过 cache-control(1.1)(max-age=毫秒)和 expires(1.0)(Date 类型值)设置，命中则不发起请求，直接调用磁盘缓存。优先级 cache-control &gt; expires。</p> <h4 id="协商缓存"><a href="#协商缓存" class="header-anchor">#</a> 协商缓存</h4> <p>服务端通过 last-modified/if-modified-since(Date 类型值)组合或者 etag/if-none-match(资源码)组合来判断，前者是服务端设置，后者是客户端请求携带。优先级 ETag &gt; Last-Modified。</p> <h4 id="其他缓存"><a href="#其他缓存" class="header-anchor">#</a> 其他缓存</h4> <p>pragma(1.0)，只有一个唯一值 no-cache。优先级 pragma &gt; cache-control。</p> <h4 id="用户行为"><a href="#用户行为" class="header-anchor">#</a> 用户行为</h4> <p>我们可以把刷新/访问界面的手段分成三类：</p> <ul><li>在 URI 输入栏中输入然后回车/通过书签访问/location.href。会通过 Expires 或者 Cache-Control 判断是否过期，未过期则不发送请求，使用缓存，返回 200</li> <li>F5/点击工具栏中的刷新按钮/右键菜单重新加载。始终会发送一个请求，并带上 etag 或者 last-modified 的值，以此来决定是否使用缓存（命中就返回 304）。</li> <li>Ctl+F5。彻底拿一份新资源。</li></ul> <h3 id="_3-tcp-连接"><a href="#_3-tcp-连接" class="header-anchor">#</a> 3. TCP 连接</h3> <ul><li>在 http/1.0 中，官方不支持持久连接，需要双端支持并指定头<code>connection: Keep-Alive</code>。</li> <li>在 http/1.1 中，支持持久连接，但一个 TCP 连接一个时刻只能处理一个 http 请求，不过多个 http 请求可以复用这次连接。</li> <li>在 http/2.0 中，一个 TCP 就可以同时处理多个 http 请求，名为 Multiplexing。</li> <li>不同浏览器对 TCP 连接的数量限制不一样，chrome/6，safari/6，firefox/32。</li></ul> <h4 id="建立，三次-🤝"><a href="#建立，三次-🤝" class="header-anchor">#</a> 建立，三次 🤝</h4> <p>TCP 是可靠连接，主要靠序号（sequence number）和确认号（acknowledgement number）来保证信息的完整、有序和无差错。</p> <p>TCP 首部如下：
<img src="/assets/img/tcp_header.7b3f75c6.jpg" alt=""></p> <p>握手中有两个常用的动作：</p> <ul><li>ACK=1，表示设置<strong>标志位 ACK</strong>为 1（注意与确认号 ack 的区别）。</li> <li>ack=x+1，表示设置<strong>数据域确认号</strong>的值为 x+1。</li></ul> <blockquote><p>TCP规定，SYN=1的报文段不能携带数据（指TCP数据部分），且会消耗掉一个序号（下次必须使用另外的序号了，比如x+1）。</p></blockquote> <p>最终，建立连接的握手流程如下（x，y 为各自的初始序号）：</p> <ol><li>C ----(SYN=1，seq=x)----&gt; S</li> <li>C &lt;----(SYN=1，ACK=1，seq=y，ack=x+1)---- S</li> <li>C ----(ACK=1，seq=x+1，ack=y+1)----&gt; S</li></ol> <h4 id="交流数据，两次-🤝"><a href="#交流数据，两次-🤝" class="header-anchor">#</a> 交流数据，两次 🤝</h4> <ul><li>C ----(ACK=1，seq=x+1，ack=y+1)----&gt; S</li> <li>C &lt;----(ACK=1，ack=x+2)---- S</li></ul> <h4 id="断开，四次-🤝"><a href="#断开，四次-🤝" class="header-anchor">#</a> 断开，四次 🤝</h4> <ul><li>C ----(FIN=1，seq=u)----&gt; S</li> <li>C &lt;----(ACK=1，seq=v，ack=u+1)---- S</li> <li>C &lt;----(FIN=1，ACK=1，seq=w，ack=u+1)---- S</li> <li>C ----(ACK=1，seq=u+1，ack=w+1)----&gt; S</li></ul> <h3 id="_4-渲染"><a href="#_4-渲染" class="header-anchor">#</a> 4. 渲染</h3> <p>浏览器内核，一个 tab 页，代表一个进程，它又拥有多个线程。</p> <ul><li>GUI 渲染线程</li> <li>js 引擎线程</li> <li>事件触发线程（ok 后放入 js 引擎的执行队列）</li> <li>定时触发线程（ok 后通知事件触发线程）</li> <li>异步 HTTP 请求线程（ok 后通知事件触发线程）</li></ul> <p>渲染过程：</p> <ul><li>HTML -&gt; DOM</li> <li>CSS -&gt; CSSOM</li> <li>DOM + CSSOM -&gt; Render Tree
<blockquote><p>Render Tree 跟 DOM Tree 并不是一一对应，比如 head 节点和 display:none 的节点</p></blockquote></li> <li>重排/回流（reflow），计算节点的几何信息（位置、大小）</li> <li>重绘（repaint），转化为屏幕的实际像素</li></ul> <p>重排代价太多，所以浏览器使用队列栈来减少消耗。因此获取几何信息时，会强制清空栈而触发重排操作。</p> <h2 id="web-安全"><a href="#web-安全" class="header-anchor">#</a> WEB 安全</h2> <h3 id="同源策略"><a href="#同源策略" class="header-anchor">#</a> 同源策略</h3> <p>浏览器拥有严格的同源策略（协议、域名、端口必须全部相同），不同源的交互就会受到限制。</p> <h4 id="解决办法"><a href="#解决办法" class="header-anchor">#</a> 解决办法</h4> <p>一般的交互，我们分为 dom 获取、cookie 获取以及事件。</p> <ul><li>dom 获取：设置 document.domain
<blockquote><p>domain 的值只能设置为当前域或父域,且不能设置协议与端口，且是交互的双方同时设置。</p></blockquote></li> <li>cookie 获取：设置 cookie 的 domain 属性
<blockquote><p>cookie 的 sameSite 属性分为三个值：</p> <ul><li><code>Strict</code> 非同源不发送 cookie。</li> <li><code>Lax</code> get 请求发送，post 不发送，img 与 script 标签不发送。</li> <li><code>None</code> 都发送</li></ul></blockquote></li> <li>事件：使用 window.postMessage</li></ul> <p>如果是要获取数据，可以使用：</p> <ol><li>JSONP</li> <li>CORS</li> <li>nginx 反向代理</li></ol> <p>TODO: 待实践验证</p> <h3 id="常见"><a href="#常见" class="header-anchor">#</a> 常见</h3> <h3 id="xss-跨站脚本（cross-site-scripting）"><a href="#xss-跨站脚本（cross-site-scripting）" class="header-anchor">#</a> XSS 跨站脚本（Cross Site Scripting）</h3> <p>分为以下几类：</p> <ul><li>存储型：input 区域输入恶意代码进入数据库，下次用户打开加载脚本。</li> <li>反射型：给个链接诱骗点击，加载恶意服务器的恶意代码</li> <li>基于 DOM 型：运行时才能发现，通过更改 dom 来加载恶意代码</li></ul> <p>预防：</p> <ul><li>设置 cookie 为 httponly</li> <li>过滤输入输出</li> <li>设置 CSP</li></ul> <h3 id="csrf-跨站请求伪造（cross-site-request-forgery）"><a href="#csrf-跨站请求伪造（cross-site-request-forgery）" class="header-anchor">#</a> CSRF 跨站请求伪造（Cross site request forgery）</h3> <p>预防：</p> <ul><li>设置 cookie 的 sameSite 属性</li> <li>接口验证来源</li></ul> <h3 id="sql-注入"><a href="#sql-注入" class="header-anchor">#</a> SQL 注入</h3> <h3 id="点击劫持"><a href="#点击劫持" class="header-anchor">#</a> 点击劫持</h3> <p>预防：</p> <ul><li>设置 X-Frame-Options，方式第三方加载 iframe 嵌套</li></ul> <h3 id="ddos，拒绝服务攻击。"><a href="#ddos，拒绝服务攻击。" class="header-anchor">#</a> DDoS，拒绝服务攻击。</h3> <h2 id="常见项目优化"><a href="#常见项目优化" class="header-anchor">#</a> 常见项目优化</h2> <ul><li>常用第三方库用 cdn 引入（公司专用最好），使用 webpack 的 externals 动态引入。</li> <li>gzip 压缩。打包时生成.gz 文件，方便 nginx 服务器直接返回文件，无需利用 cpu 计算。</li> <li>preload 预加载首屏需要图片</li> <li>dns-prefetch 预解析需要跨域的 dns</li> <li>首屏使用动画，提前渲染，减少用户的焦虑感</li> <li>moment.js 改为使用 day.js</li> <li>图片懒加载。</li></ul> <ol><li>在 scroll 事件里处理（根据 getBoundingClientRect 接口获取 top 与 scrollTop 比对），需要注意几点（事件函数节流，首次先运行一次，滚动完毕移除事件）</li> <li>或者使用 IntersectionObserver 构造函数管擦判断是否加载图片</li> <li>使用 vue-lazyload 插件</li></ol> <ul><li>图片使用.webp 格式，为了兼容不使用的环境，使用 picture 标签来设定一层层的兼容</li> <li>减少 DOM 操作。避免获取视图信息（getBoundingClientRect,clientWidth,offsetWidth）,因为它会立即更新浏览器重排/重绘维护的队列。高频事件防抖节流。</li> <li>打包优化，使用 DllPlugin 分离第三方类库，使用 add-asset-html-webpack-plugin 来注入到 index.html 中</li></ul> <h2 id="http-状态码"><a href="#http-状态码" class="header-anchor">#</a> HTTP 状态码</h2> <ul><li>301，永久重定向。浏览器会更新缓存，下次直接到新的页面；SEO 会转移相应旧站的流量排名到新站，但是内容一定要高度一致，不然视为黑帽 SEO。</li> <li>302，临时重定向</li></ul> <h2 id="cors（跨域资源共享）"><a href="#cors（跨域资源共享）" class="header-anchor">#</a> CORS（跨域资源共享）</h2> <p>根据 method 与 request header 决定是 simple request 还是 not-so-simple request。</p> <h3 id="simple-request"><a href="#simple-request" class="header-anchor">#</a> simple request</h3> <ul><li>method: PUT、GET、POSAT</li> <li>header: 基本字段，注意 content-type 只允许 application/x-www-form-urlencoded、multipart/form-data、text/plain，<strong>也就是 json 参数是算 not-so-simple request</strong>。</li></ul> <p>处理方法为浏览器自动带上 origin 字段，服务器进行逻辑判断，给出 response。</p> <p>如果允许，服务器在 response header 中设置<code>Access-Control-Allow-Origin: *</code>，或者为 origin 的值。</p> <p>如果不允许，正常返回信息与头，浏览器判断没有相应的头，自动识别请求失败。</p> <p>如果还需要发送 Cookie，需要双方操作，浏览器需要在 ajax 中设置<code>withCredential = true</code>，服务器在 response header 中设置，<code>Access-Control-Allow-Credentials: true</code>。<strong>另外<code>Access-Control-Allow-Origin</code>这时就不能返回*了，必须为明确的地址。</strong></p> <h3 id="not-so-simple-request"><a href="#not-so-simple-request" class="header-anchor">#</a> not-so-simple request</h3> <p>会在请求之前发送一次 method 为<code>OPTIONS</code>的“预检”请求。判断逻辑同 simple request。</p> <p>但是 request header 会有两个特殊字段：</p> <ul><li><code>Access-Control-Request-Method</code>，包含 cors 会用到的方法。</li> <li><code>Access-Control-Request-Headers</code>，一个以逗号分隔的字符串，包含 cors 会额外发送的头信息字段，<strong>如果浏览器发送了这个字段，那么服务器也必须按返回相应的<code>Access-Control-Allow-Headers</code>字段，否则预检失败。</strong></li></ul> <p>预检请求只发一次，后面的 not-so-simple request 当做 simple request 请求处理，因为服务器可以在第一次预检请求的 response header 中设置<code>Access-Control-Max-Age</code>。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/dac/" class="prev">
        数据结构与算法
      </a></span> <span class="next"><a href="/git/">
        git
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.ed89f765.js" defer></script><script src="/assets/js/2.ee146c9e.js" defer></script><script src="/assets/js/6.d71a63f2.js" defer></script>
  </body>
</html>
